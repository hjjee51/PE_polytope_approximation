import numpy as np
import itertools as it
import cvxpy as cp
import math
import random
from math import sqrt

SOLVER = 'MOSEK'

party_labels = ['A', 'B', 'C', 'D', 'E', 'F', 'G']

def get_indices(dimA, dimQ):
	### Get all possible indices for [dimA, dimQ]
    indices_list = [[i, j] for i,j in it.product(range(dimA-1), range(dimQ))]
    return indices_list

def hermitian(element):
	element_dagger = element.copy()
	for key in element_dagger.keys():
		element_dagger[key] = element_dagger[key][::-1]
	return element_dagger

def is_conjugate(element, mon_list):
    for i, mon in enumerate(mon_list):
        n_success = 0
        if set(element.keys())==set(mon.keys()):
            for key in element.keys():
                if element[key]==mon[key][::-1]:
                    n_success += 1
            if n_success == len(element.keys()): return i
        else: continue
    return False

def sort_out_indices(indices_in_list):
	'''
	Input - 'indices': a list of indices, ex) [[1,0],[0,0]]
	Output - simplified list of indices or 0
	A function sorting out indices. 
	Namely, using the two properties of projective measurement operators,
    (1) E^2 = E, (2) E(a|x)E(b|y) = 0 when a!=b but x=y,
    this function simplifies the input indices.
    For example, if the input is [[1,0],[0,0]], then it returns 0.
    If the input is [[0,0],[0,0],[0,1]], then it returns [[0,0],[0,1]]
	'''
	if len(indices_in_list)==1:
		return indices_in_list
	else:
		sorted_indices = [indices_in_list[0].copy()]
		for i in range(1,len(indices_in_list)):
			# print("sorted_indices: ", sorted_indices)
			if sorted_indices[-1]==indices_in_list[i]: continue ## E^2=E
			elif (sorted_indices[-1][0]!=indices_in_list[i][0]) and (sorted_indices[-1][1]==indices_in_list[i][1]): ## Orthogonal projectors
				sorted_indices = 0
				break
			else:
				sorted_indices.append(indices_in_list[i])
		return sorted_indices

def generate_all_product_of_two(M_list1, M_list2):
	'''
	A function generating all monomials generated by multiplying two lists of monomials
	Input - 'M_list1': a list of monomials (dictionaries)
		  - 'M_list2': a list of monomials (dictionaries)
	Output - A list of dictionaries
	'''
	M_list = []
	for element in it.product(M_list1, M_list2):
		parties_in = []
		for i in range(2): # Check how many different parties exist in this product
			if element[i][0] not in parties_in:
				parties_in.append(element[i][0])

		sorted_element = {}
		for i in range(len(parties_in)): # Create a dictionary key for each existing party
			sorted_element[parties_in[i]] = []
		for i in range(2): # Classify the indices to the matching key (party)
			sorted_element[element[i][0]].append(element[i][1])

        # Sort out indices. Namely, using the two properties of projective measurement operators,
        # (1) E^2 = E, (2) E(a|x)E(b|y) = 0 when a!=b but x=y,
        # simplify the indices. 'sort_out_indices()' does this job.
		for i in range(len(parties_in)):
			sorted_element[parties_in[i]] = sort_out_indices(sorted_element[parties_in[i]])

		# Check whether the measurement operator is already in the list.
		new = True
		for i in range(len(M_list)):
			if M_list[i]==sorted_element: new=False
			else: continue

		if 0 in sorted_element.values(): continue # When the measurement operator is zero, skip the turn
		elif not new: continue # Whe the measurement operator is not new, skip the turn
		else: M_list.append(sorted_element)
	return M_list


def generate_all_product(M_list_set):
	'''
	A function generating all monomials generated by multiplying all of given lists of monomials.
	Input - 'M_list_set': a set of lists of monomials (dictionaries)
	Output - A list of dictionaries
	'''
	n_list = len(M_list_set) # The number of given lists of monomials.
	M_list = []
	for element in it.product(*M_list_set):
		parties_in = []
		for i in range(n_list): # Check how many different parties exist in this product
			if element[i][0] not in parties_in:
				parties_in.append(element[i][0])

		sorted_element = {}
		for i in range(len(parties_in)): # Create a dictionary key for each existing party
			sorted_element[parties_in[i]] = []
		for i in range(n_list): # Classify the indices to the matching key (party)
			sorted_element[element[i][0]].append(element[i][1])

        # Sort out indices. Namely, using the two properties of projective measurement operators,
        # (1) E^2 = E, (2) E(a|x)E(b|y) = 0 when a!=b but x=y,
        # simplify the indices. 'sort_out_indices()' does this job.
		for i in range(len(parties_in)):
			sorted_element[parties_in[i]] = sort_out_indices(sorted_element[parties_in[i]])

		# Check whether the measurement operator is already in the list.
		new = True
		for i in range(len(M_list)):
			if M_list[i]==sorted_element: new=False
			else: continue

		if 0 in sorted_element.values(): continue # When the measurement operator is zero, skip the turn
		elif not new: continue # Whe the measurement operator is not new, skip the turn
		else: M_list.append(sorted_element)
	return M_list

'''
This function combine two dictionaries.
The difference from the built-in 'update' function is
that this function keeps the old values and append the new values.
For example, if dict1 = {'A':[[0,0]], 'B':[[1,0]]} and dict2 =  {'A':[[1,0]], 'c':[[1,1]]},
then it returns {'A':[[0,0],[1,0]], 'B':[[1,0]], 'C':[[1,1]]}.
'''
def combine_two_dicts(dict1, dict2):
    combined_dict = {}
    keys = list(dict1.keys())
    [keys.append(key2) for key2 in dict2.keys() if key2 not in keys]
    for key in keys:
        item = []
        if key in dict1.keys():
            item.extend(dict1[key])
        if key in dict2.keys():
            item.extend(dict2[key])
        combined_dict[key] = item
    return combined_dict

'''
A function returning a marginal probability distribution of given indices
Input - pd: full probability distribution
	  - indices: a dictionary containing remaining paties and indices
Output - the corresponding element of the marginal probaility distribution (number)

For example, if 'pd' is a tripartite probability distribution, p[a,b,c,x,y,z],
and 'indices' is {'A':[[0,0]], 'C':[[1,0]]}, then the function traces out B system,
i.e., p[a,b,c,x,y,z] -> p[a,c,x,z], and return the number p[a=0,c=1,x=0,z=0].
'''
def get_marginal(pd, indices):
    # Get the information of full statistics: 
    # ex) the full number of parties, dimensions of answer and question of each party...
    n_parties = int(len(np.shape(pd))/2)
    dim_answers = list(np.shape(pd))[:n_parties]
    dim_questions = list(np.shape(pd))[n_parties:]
    
    n_marg = len(indices.keys()) # The number of remaining parties in the marginal
    if n_marg == n_parties: # When it is a full probabilty distribution (no need to trace out anything)
        ans_list = []
        que_list = []
        for i in range(n_marg):
            ans_list.append(indices[party_labels[i]][0][0])
            que_list.append(indices[party_labels[i]][0][1])
        ans_list.extend(que_list) # The indices order: a_1, a_2, ..., a_n, q_1, q_2, ..., q_n
        # print("Marginal indices: ", ans_list)
        return pd.item(*ans_list)
    elif n_marg < n_parties: # When we need to compute the marginal
        pd_marginal = pd.copy()
        marg_list = [party_labels[i] for i in range(n_parties)] # The keys (strings, ex 'A') of the remaining parties
        summed_list = []
        for label in party_labels[:n_parties]: # Get the list of labels of the parties which need to be traced out
            if label not in indices.keys(): 
                marg_list.remove(label)
                summed_list.append(label)
                
        # Trace out the parties not in indices
        for count, label in enumerate(summed_list):
            index = party_labels.index(label)
            pd_marginal = np.moveaxis(np.sum(pd_marginal,axis=(index-count)), n_parties-2*count+index-1, 0)[0]
            # Because of the no-signalling condition, we can always pick q=0 after suming up.

        ans_list = []
        que_list = []
        for label in marg_list:
            ans_list.append(indices[label][0][0])
            que_list.append(indices[label][0][1])
        ans_list.extend(que_list) # The indices order: a_1, a_2, ..., a_n, q_1, q_2, ..., q_n
        return pd_marginal.item(*ans_list)
    else:
        raise Exception('There cannot be more parties in the marginal than the full probability distribution.')


'''
Function generating the corresponding NPA matrix for given input probability distribution 'p' and the 'level'.
Input - 'p': numpy array
	  - 'level': either a number or string like '1+AA+AB'
Output - corresponding NPA matrix

It can handle the case when
(1) 'p' is multipartite
(2) additional levels in 'level' only include up to 2 systems (could be improved later) 
	-> 11/03/2022 Fixed the problem. Now it can take additional levels including an arbitrary number of parties.
'''
def generate_NPA_matrix(p, level, sub_norm=0):

	### Find out the level
	if isinstance(level, int):
	    base_k = level
	    max_k = level
	    num_k_compon = 1
	    addi_k = []
	elif isinstance(level, str):
	    split_k = level.split('+')
	    num_k_compon = len(split_k)
	    base_k = int(split_k[0])
	    addi_k = split_k[1:]
	    max_k = base_k
	    for i in range(1, num_k_compon):
	        max_k = max(max_k, len(split_k[i]))
	else:
	    raise Exception('The level must be a positive integer or a string.')


	### Check whether p is a true probability distribution
	## 1. All entries are non-negative, and the sum is smaller than or equal to 1
	## 2. (Later) Same for marginal
	size_p = np.shape(p)
	n_parties = int(len(size_p)/2)
	if n_parties>7:
		raise Exception('Too many parties.')
	dim_answers = size_p[:n_parties]
	dim_questions = size_p[n_parties:]

	######################### TO BE DONE #########################################
	# is_prob_positive = all(x >= 0 for x in p.flatten())
	# sum_p = p.copy()
	# for i in range(n_parties):
	#     sum_p = sum_p.sum(axis=0)
	# is_prob_subnorm = all(s<=1 for s in sum_p.flatten())

	## This part does not work yet
	# for index, Q in enumerate(dim_questions):
	#     p_mar_q_list = p.sum(axis=index).swapaxes(0,(n_parties+index-1))
	#     print(p_mar_q_list)
	#     is_prob_marginal = all(np.isclose(p_mar_q, p_mar_q_list[0]) for p_mar_q in p_mar_q_list)
	        
	# if not is_prob_positive:
	#     raise Exception('Given p is not a true probability distribution; there exists a non-positive element.')
	# if not is_prob_subnorm:
	#     raise Exception('Given p is not a true probability distribution; not subnormalised.')
	# if not is_prob_marginal:
	#     raise Exception('Given p is not a true probability distribution: marginals do not match.')
	##################################################################################


	### Generate all products of measurements (monomials) for the given level
	## One monomial is represented by a dictionary: for example, 
	## {'A':[[0,1],[1,0]], 'B':[[1,1]]} represents a product E_A(0|1)E_A(1|0)E_B(1|1).
	## The keys of a monomial indicate the labels of the parties existing in the product,
	## and the values represent the index of each measurement in the product;
	## [0,1] with key 'A' means the measurement operator E_A(a=0|x=1).
	## The base monomial list: S_1 in the NPA paper, e.g., {E_A}U{E_B}U{E_C} in the tripartite case.
	base_dic = {}
	base_list = []
	for l in range(n_parties):
	    one_party = []
	    for index in get_indices(dim_answers[l], dim_questions[l]):
	        base_list.append([party_labels[l], index])
	        one_party.append([party_labels[l], index])
	    base_dic[party_labels[l]] = one_party

	## Generate all products of measurement (monomials) for the base level 'base_k'.
	M_list = [{}]
	for k in range(base_k):
	    for element in it.product(base_list, repeat=(k+1)):
	        parties_in = []
	        for i in range(k+1): # Check how many different parties exist in this product
	            if element[i][0] not in parties_in:
	                parties_in.append(element[i][0])

	        sorted_element = {}
	        for i in range(len(parties_in)): # Create a dictionary key for each existing party
	            sorted_element[parties_in[i]] = []
	        for i in range(k+1): # Classify the indices to the matching key (party)
	            sorted_element[element[i][0]].append(element[i][1])

	        # Sort out indices. Namely, using the following two properties of projective measurement operators,
	        # (1) E^2 = E, (2) E(a|x)E(b|y) = 0 when a!=b but x=y,
	        # simplify the indices. The function 'sort_out_indices()' does this job.
	        for i in range(len(parties_in)):
	            sorted_element[parties_in[i]] = sort_out_indices(sorted_element[parties_in[i]])

	        # Check whether the measurement operator is already in the list.
	        new = True
	        for i in range(len(M_list)):
	            if M_list[i]==sorted_element: 
	                new=False
	                break
	            else: continue

	        if 0 in sorted_element.values(): continue # When the measurement operator is zero, skip the turn
	        elif not new: continue # Whe the measurement operator is not new, skip the turn
	        else: M_list.append(sorted_element)

	## Generate all product of measurements (monomials) for the additional levels 'addi_k'.
	for level in addi_k:
	    # if len(level)>2:
	    #     raise Exception('All additional levels must include up to 2 parties.') # [TO DO]: It can be improved
	    # party1_M_list = base_dic[level[0]]
	    # party2_M_list = base_dic[level[1]]
	    M_list_set = []
	    for i in range(len(level)):
	    	M_list_set.append(base_dic[level[i]])
	    prod_M_list = generate_all_product(M_list_set)
	    
	    for element in prod_M_list:
	        new = True
	        for i in range(len(M_list)):
	            if M_list[i]==element: 
	                new=False
	                break
	            else: continue
	        if not new: continue
	        else: M_list.append(element)

	### Construct the corresponding NPA matrix
	NPA_matrix = []
	var_list = []
	var_indices_list = []

	for a,row_element in enumerate(M_list):
	    NPA_matrix_row = []
	    for b,column_element in enumerate(M_list):
	        element = combine_two_dicts(hermitian(row_element), column_element) # Combine the row monomial and the column monomial	        
	        for i in element.keys():
	            element[i] = sort_out_indices(element[i])
	            
	        # If there is zero in values (when the monomial is zero), then append zero
	        if element=={}:
	        	sum_axis = tuple(range(n_parties))
	        	NPA_matrix_row.append(np.sum(p, axis=sum_axis).flatten()[0])
	        	# print("normalisation")
	        	continue
	        if 0 in element.values():
	            NPA_matrix_row.append(0)
	            # print(0)
	            continue

	        len_list = [len(el) for el in element.values()]
	        if all(l==1 for l in len_list):
	        	# If the degree of the monomial is 1, we can calculate the matrix element using 'p'.
	            NPA_matrix_row.append(get_marginal(p, element))
	            # print("marginal")
	            continue
	        else:
	        	# If the degree of the monomial of any party is larger than 1, append a complex variable (the element is not a probability anymore).
	        	# Matrix elements with same monomial (or cyclic permutations of itself) have the same variable.
	        	if element in var_indices_list:
	        		NPA_matrix_row.append(var_list[var_indices_list.index(element)])
	        		# print("Already in the list. Index: ", element)
	        		continue
	        	
	        	check_conjugate = is_conjugate(element, var_indices_list)
	        	if not isinstance(check_conjugate, bool):
	        		NPA_matrix_row.append(cp.conj(var_list[check_conjugate]))
	        		# print("Conjugate in the list. Index: ", var_indices_list[check_conjugate])
	        		continue
	        	else:
	        		if a==b: 
	        			new_var = cp.Variable()
	        			# print('New')
	        		else:
	        			new_var = cp.Variable(complex=True)
	        		NPA_matrix_row.append(new_var)
	        		# print("New variable. Number:", len(var_list))
	        		var_list.append(new_var)
	        		var_indices_list.append(element)
	        		continue
	    
	    NPA_matrix.append(NPA_matrix_row)	
	
	return cp.bmat(NPA_matrix)

def check_quantum_NPA(p, level, show=False):

	NPA_matrix = generate_NPA_matrix(p, level)
	constraint = [NPA_matrix >> 0]
	
	check_Q = cp.Problem(cp.Minimize(0), constraint)
	check_Q.solve(verbose=show, solver=SOLVER)

	if check_Q.value == 0: is_quantum=True
	else: is_quantum=False

	return is_quantum